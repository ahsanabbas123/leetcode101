---
layout: post
title: LC 206. Reverse Linked List 
categories: [top interview, easy, linked list]
author: Nilanjan Deb
---
## Approach 1: Iterative (Long Code)

I solved this problem for my academic course 'COMPUTER PROGRAMMING'. Here I used two pointer namely p,q for traversing the linked list. And a temporary pointer to store data of q while traversing.
First of all, for corner cases viz. zero and one element return dirctltly head.
Then I store the data of head to p and put NULL to the next of head(head->next), Same procedure I follow while traversing firstly I store the data q moves one element faster than p, while traversing firstly I store the data of q in store pointer and move q one forwards then connect the current pointer to the previous pinter and so on Up to q becomes NULL.

This is my CPP solution.

```
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(head==NULL || head->next==NULL){
            return head;
        }
        ListNode *p = head ,*q = head->next;
        head->next = NULL;
        while(q!=NULL){
            ListNode *store = q;
            q = q->next;
            store->next = p;
            p = store;
        }
        return p;
    }
};
```
## Approach 2: Iterative (Short Code)

```
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *prev = NULL;
        while (head) {
            ListNode* temp = head->next;
            head->next = prev;
            prev = head;
            head = temp;
        }
        
        return prev;
    }
};
```

## Approach 3: Recursive

Recurse till the end of the list and return the last node. After each function call pop from the recursion stack, reverse the next pointer. See code below:

```
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (!head || !head->next)
            return head;
        ListNode* temp = reverseList(head->next);
        head->next->next = head;
        head->next = NULL;
        return temp;
    }
}
```

```
Let's say the list is 1->2->3:
Recursion: reverseList(1) -> reverseList(2) -> reverseList(3)
reverseList(3) returns "3"
Then, in the function reverseList(2) function: head is 2. head->next is 3. So head->next->next = head implies 3->next = 2 hence reversing the arrow. head->next= NULL so 2->next = NULL. Now, our list is 1->2<-3

reverseList(2) returns "3" (temp)
Then, in the function reverseList(1): head is 1. head->next is 2. So head->next->next = head imples 2->next = 1 hence reversing the arrow. head->next = NULL implies 1->next = NULL. Now, our list is reversed! 1<-2<-3

reverseList(1) returns "3" (temp) which is the head of our new list.
```